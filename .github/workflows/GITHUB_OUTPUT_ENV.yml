name: test GITHUB_OUTPUT/GITHUB_ENV
on:
  workflow_dispatch:
  push:
    branches: 
      - dev
    # branches-ignore:
    #   - dev

jobs:

  job1:
    name: hello job 1
    runs-on: ubuntu-latest
    # this is to be used in other jobs and not same job (job1)
    outputs:
      output1: ${{ steps.id1.outputs.my_output1 }}
      output2: ${{ steps.id2.outputs.my_output2 }}

    steps:    
      # write to GITHUB_ENV in step1,2 and read in step3
      - name: step1, usual way
        run: |
          echo my_GITHUB_ENV1=aaaaaaaaaaaaaaaaaaaaa >> $GITHUB_ENV

      - name: step2, using heredoc (multi line)
        run: |
          cat <<lolo >> $GITHUB_ENV
          my_GITHUB_ENV2=bbbbbbbbbbbbbbbbbbbbbb
          my_GITHUB_ENV3=cccccccccccccccccccccc
          lolo

      - name: step3, reading content of GITHUB_ENV in 2 ways in same job
        run: |
          echo step1 output: $my_GITHUB_ENV1
          echo step2 output: $my_GITHUB_ENV2
          echo step2 output: ${{ env.my_GITHUB_ENV3 }}


      # same as above but using step id.
      - name: step4, writing a value to GITHUB_OUTPUT
        id: step4_id
        run: |
          echo my_output1=ddddddddddddddddddddd >> $GITHUB_OUTPUT
        
      - name: step5, reading a value from GITHUB_OUTPUT
        run: |
          echo step4 output: ${{ steps.step4_id.outputs.my_output1 }}
  

      # # to be used in other jobs
      # - name: step6, writing a value to GITHUB_OUTPUT using my_output1
      #   id: id1
      #   run: |
      #     echo "my_output1=This is" >> $GITHUB_OUTPUT

      # - name: step7,  writing a value to GITHUB_OUTPUT using my_output2
      #   id: id2
      #   run: |
      #     echo "my_output2=Ardevan" >> $GITHUB_OUTPUT
# *****************************************************************************************
  # job2:
  #   name: hello job 2
  #   runs-on: ubuntu-latest
  #   outputs:
  #     output1: ${{ steps.id1.outputs.my_output1 }}
  #     output2: ${{ steps.id2.outputs.my_output2 }}

  #   steps:
  #     - name: writing a value to GITHUB_OUTPUT using my_output1
  #       id: id1
  #       run: |
  #         echo "my_output1=learning" >> $GITHUB_OUTPUT

  #     - name: writing a value to GITHUB_OUTPUT using my_output2
  #       id: id2
  #       run: |
  #         echo "my_output2=how writing to and" >> $GITHUB_OUTPUT
# *****************************************************************************************  
  # job3:
  #   name: hello job 3
  #   runs-on: ubuntu-latest
  #   outputs:
  #     output1: ${{ steps.id1.outputs.my_output1 }}
  #     output2: ${{ steps.id2.outputs.my_output2 }}

  #   steps:
  #     - name: writing a value to GITHUB_OUTPUT using my_output1
  #       id: id1
  #       run: |
  #         echo "my_output1=reading from" >> $GITHUB_OUTPUT    

  #     - name: writing a value to GITHUB_OUTPUT using my_output2
  #       id: id2
  #       run: |
  #         echo "my_output2=to GITHUB_OUTPUT works" >> $GITHUB_OUTPUT
  # *****************************************************************************************
  # job4:
  #   name: hello job 4
  #   runs-on: ubuntu-latest
  #   needs: [job1, job2, job3]
  #   steps:
  #     - name: reading contents of GITHUB_OUTPUT from job 1,2 and 3
  #       run: |
  #         echo ${{ needs.job1.outputs.output1 }} ${{ needs.job1.outputs.output2 }} 
  #         echo ${{ needs.job2.outputs.output1 }} ${{ needs.job2.outputs.output2 }} 
  #         echo ${{ needs.job3.outputs.output1 }} ${{ needs.job3.outputs.output2 }}